<html>
<head>
    <title>GAN-generated Chairs</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="icon" type="image/png" href="favicon.png">
</head>

<body>
    <div id="container"></div>

    <div class="overlay">
        <h1>GAN-generated Chairs</h1>
        <div class="controls">
            <button id='generate'>Generate</button>
            <button id='save'>Save STL</button>
        </div>
        <div id="status">Loading model...</div>
        <div class="description-container">
            <div class="description">
                This shape was created by a <a href="https://en.wikipedia.org/wiki/Generative_adversarial_network">generative adversarial network</a> (GAN) for 3D shapes that was trained on a <a href="https://www.shapenet.org/">dataset</a> of chairs.
                <br>
                <a href="https://arxiv.org/abs/2002.00349">Read the paper</a> &#183; 
                <a href="https://marian42.de/article/shapegan/">Read the blog post</a> &#183;
                <a href="https://github.com/marian42/shapegan">Source Code</a> &#183;
                <a href="https://marian42.de/" class="dark">marian42.de</a> &#183;
                <a href="https://marian42.de/page/imprint/" class="dark">Imprint</a>
            </div>
        </div>
    </div>

    <style>
        body {
            padding: 0;
            margin: 0;

            color: #bfbfbf;
            background-color: #0f1012;
            font-family: sans-serif;
        }

        a, a:visited {
            color: #bfbfbf;
        }

        .overlay {
            position: fixed;
            width: 100%;
            top: 0px;
            left: 0px;
            display: block;
        }

        h1 {
            text-align: center;
            margin: 10px;
        }

        #status {
            text-align: center;
            height: 28px;
            margin: 4px;
        }

        .controls {
            text-align: center;
        }

        button {
            display: inline-block;
            padding: 10px 20px;
            margin: 0 0.3em 0.3em 0;
            border-radius: 4px;
            box-sizing: border-box;
            color: #FFFFFF;
            background-color: #0076E3;
            text-align: center;
            transition: all 0.2s;
            border: none;
        }
        button:hover {
            background-color: #005aad;
        }
        button:focus {
            outline: 0;
        }
        button:active {
            position: relative;
            top: 1px;
        }

        .description-container {
            position: fixed;
            width: 100%;
            bottom: 0px;
            left: 0px;
            display: block;
            text-align: center;
        }

        .description {
            width: calc(min(100% - 20px, 800px));
            text-align: left;
            display: inline-block;
            font-size: 0.9em;
            line-height: 1.5em;
            padding: 10px;
        }

        a.dark {
            color: #636363;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/onnxjs/dist/onnx.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/marchingcubes.js"></script>
    <script>
        "use strict";

        // https://filosophy.org/code/normal-distributed-random-values-in-javascript-using-the-ziggurat-algorithm/
        function Ziggurat() {
            var jsr = 123456789;

            var wn = Array(128);
            var fn = Array(128);
            var kn = Array(128);

            function RNOR() {
                var hz = SHR3();
                var iz = hz & 127;
                return (Math.abs(hz) < kn[iz]) ? hz * wn[iz] : nfix(hz, iz);
            }

            this.nextGaussian = function() {
                return RNOR();
            }

            function nfix(hz, iz){
                var r = 3.442619855899;
                var r1 = 1.0 / r;
                var x;
                var y;
                while (true) {
                    x = hz * wn[iz];
                    if (iz == 0){
                        x = (-Math.log(UNI()) * r1); 
                        y = -Math.log(UNI());
                        while (y + y < x * x) {
                            x = (-Math.log(UNI()) * r1); 
                            y = -Math.log(UNI());
                        }
                        return (hz > 0) ? r+x : -r-x;
                    }

                    if (fn[iz] + UNI() * (fn[iz-1] - fn[iz]) < Math.exp(-0.5 * x * x)){
                        return x;
                    }
                    hz = SHR3();
                    iz = hz & 127;

                    if (Math.abs(hz) < kn[iz]){
                        return (hz * wn[iz]);
                    }
                }
            }

            function SHR3() {
                var jz = jsr;
                var jzr = jsr;
                jzr ^= (jzr << 13);
                jzr ^= (jzr >>> 17);
                jzr ^= (jzr << 5);
                jsr = jzr;
                return (jz+jzr) | 0;
            }

            function UNI() {
                return 0.5 * (1 + SHR3() / -Math.pow(2,31));
            }

            function zigset() {
                // seed generator based on current time
                jsr ^= new Date().getTime();

                var m1 = 2147483648.0;
                var dn = 3.442619855899;
                var tn = dn;
                var vn = 9.91256303526217e-3;
                
                var q = vn / Math.exp(-0.5 * dn * dn);
                kn[0] = Math.floor((dn/q)*m1);
                kn[1] = 0;

                wn[0] = q / m1;
                wn[127] = dn / m1;

                fn[0] = 1.0;
                fn[127] = Math.exp(-0.5 * dn * dn);

                for (var i = 126; i >= 1; i--) {
                    dn = Math.sqrt(-2.0 * Math.log( vn / dn + Math.exp( -0.5 * dn * dn)));
                    kn[i+1] = Math.floor((dn/tn)*m1);
                    tn = dn;
                    fn[i] = Math.exp(-0.5 * dn * dn);
                    wn[i] = dn / m1;
                }
            }
            zigset();
        }

        const normalDistribution = new Ziggurat();
        const LATENT_CODE_SIZE = 128;
        const BATCH_SIZE = 4096;
        var resolution = 24;

        var currentShape = null;
        var gridCache = {};

        function getGrid(resolution) {
            if (resolution in gridCache) {
                return gridCache[resolution];
            }

            var result = [];
            var currentBatch = new Float32Array(BATCH_SIZE * 3);
            var p = 0;

            for (var x = 0; x < resolution; x++) {
                for (var y = 0; y < resolution; y++) {
                    for (var z = 0; z < resolution; z++) {
                        if (p == BATCH_SIZE * 3) {
                            p = 0;
                            result.push(new onnx.Tensor(currentBatch, 'float32', [BATCH_SIZE, 3]));
                            var currentBatch = new Float32Array(BATCH_SIZE * 3);
                        }

                        currentBatch[p + 0] = -1 + 2 * x / (resolution - 1);
                        currentBatch[p + 1] = -1 + 2 * y / (resolution - 1);
                        currentBatch[p + 2] = -1 + 2 * z / (resolution - 1);
                        p += 3;
                    }
                }
            }
            result.push(new onnx.Tensor(currentBatch, 'float32', [BATCH_SIZE, 3]));
            gridCache[resolution] = result;
            return result;
        }

        function getRandomLatentCode() {
            var values = new Float32Array(LATENT_CODE_SIZE);
            for (var i = 0; i < LATENT_CODE_SIZE; i++) {
                values[i] = normalDistribution.nextGaussian();
            }
            return values;
        }

        function createLatentCodeBatch(code) {
            var result = new Float32Array(LATENT_CODE_SIZE * BATCH_SIZE);            
            for (var i = 0; i < BATCH_SIZE; i++) {
                for (var j = 0; j < LATENT_CODE_SIZE; j++) {
                    result[i * LATENT_CODE_SIZE + j] = code[j];
                }
            }
            return new onnx.Tensor(result, 'float32', [BATCH_SIZE, LATENT_CODE_SIZE]);
        }

        function writeVector(view, offset, vector) {
            view.setFloat32(offset, vector[2], true);
            view.setFloat32(offset + 4, vector[0], true);
            view.setFloat32(offset + 8, vector[1], true);
        }

        function createSTLFile(mesh) {
            var size = 84 + 50 * mesh.triangles.length;
            var buffer = new ArrayBuffer(size);
            let view = new DataView(buffer, 0, size);

            for (var i = 0; i < 80; i++) {
                view.setInt8(i, 0);
            }
            
            var p = 80;
            view.setInt32(p, mesh.triangles.length, true);
            p += 4;

            for (var triangle of mesh.triangles) {
                writeVector(view, p, [1, 0, 0]); // normal
                writeVector(view, p + 12, mesh.vertices[triangle[0]]);
                writeVector(view, p + 24, mesh.vertices[triangle[1]]);
                writeVector(view, p + 36, mesh.vertices[triangle[2]]);
                view.setInt16(p + 48, 0, true);
                p += 50;
            }

            return buffer;
        }        

        class Shape {
            constructor(latentCode, resolution) {
                this.latentCode = latentCode;
                this.resolution = resolution;
                this.batchCount = Math.ceil(Math.pow(resolution, 3) / BATCH_SIZE);
                this.surfaceLevel = 0.04;
            }

            generate() {
                setStatus('Generating...');
                this.grid = getGrid(this.resolution);
                this.latentCodeBatch = createLatentCodeBatch(this.latentCode);
                this.sdfBatches = [];
                this.updateBatch();
            }

            updateBatch() {
                if (this.sdfBatches.length == this.batchCount) {
                    this.onInferenceComplete();
                } else {
                    var batchIndex = this.sdfBatches.length;
                    onnxSession.run([this.grid[batchIndex], this.latentCodeBatch]).then(output => {
                        this.sdfBatches.push(output.values().next().value.data);
                        this.updateBatch();
                    });
                }
            }

            onInferenceComplete() {
                var paddedResolution = this.resolution + 2;
                var voxels = new Float32Array(Math.pow(paddedResolution, 3));
                voxels.fill(1);
                for (var x = 0; x < this.resolution; x++) {
                    for (var y = 0; y < this.resolution; y++) {
                        for (var z = 0; z < this.resolution; z++) {
                            var index = x * resolution * resolution + y * resolution + z;
                            var networkOutput = this.sdfBatches[Math.floor(index / BATCH_SIZE)][index % BATCH_SIZE];
                            voxels[(x + 1) * paddedResolution * paddedResolution + (y + 1) * paddedResolution + z + 1] = networkOutput - this.surfaceLevel;
                        }
                    }
                }

                this.mesh = marchingCubes(
                    [paddedResolution, paddedResolution, paddedResolution],
                    (x, y, z) => voxels[paddedResolution * paddedResolution * x + paddedResolution * y + z],
                );
                this.show();
                setStatus('');
            }

            saveSTLFile() {
                let blob = new Blob([createSTLFile(this.mesh)], { type: "application/octet-stream" });
                let link = document.createElement('a');
                link.href = window.URL.createObjectURL(blob);
                link.download = "shape.stl";
                link.click();
            }

            createGeometry() {                
                geometry = new THREE.Geometry();
                geometry.vertices.length = 0;
                geometry.faces.length = 0;

                for (var i = 0; i < this.mesh.vertices.length; ++i) {
                    var v = this.mesh.vertices[i];
                    geometry.vertices.push(new THREE.Vector3(v[0], v[1], v[2]));
                }

                for (var i = 0; i < this.mesh.triangles.length; ++i) {
                    var triangle = this.mesh.triangles[i];
                    geometry.faces.push(new THREE.Face3(triangle[0], triangle[1], triangle[2]));
                }

                var cb = new THREE.Vector3(), ab = new THREE.Vector3();
                for (var i = 0; i < geometry.faces.length; ++i) {
                    var triangle = geometry.faces[i];
                    var vA = geometry.vertices[triangle.a];
                    var vB = geometry.vertices[triangle.b];
                    var vC = geometry.vertices[triangle.c];
                    cb.subVectors(vC, vB);
                    ab.subVectors(vA, vB);
                    cb = cb.cross(ab);
                    cb.normalize();
                    triangle.normal.copy(cb);
                }

                geometry.verticesNeedUpdate = true;
                geometry.elementsNeedUpdate = true;
                geometry.normalsNeedUpdate = true;

                geometry.computeBoundingBox();

                return geometry;
            }

            show() {
                scene.remove(meshObject);

                var geometry = this.createGeometry();
                meshObject = new THREE.Mesh(geometry, material);

                var boundingBox = geometry.boundingBox;
                var scale = 2 / (this.resolution + 2);
                meshObject.position.x = -(this.resolution + 2) / 2.0 * scale;
                meshObject.position.y = -(this.resolution + 2) / 2.0 * scale;
                meshObject.position.z = -(this.resolution + 2) / 2.0 * scale;
                meshObject.scale.set(scale, scale, scale);

                scene.add(meshObject);
            }
        }

        const onnxSession = new onnx.InferenceSession();

        function setStatus(value) {
            document.getElementById('status').innerText = value;
        }

        function generateShape() {
            var latentCode = getRandomLatentCode();
            currentShape = new Shape(latentCode, resolution);
            currentShape.generate();
        }
        
        onnxSession.loadModel("chairs.onnx").then(() => {
            setStatus('Ready');
            generateShape();
        });

        var scene, renderer;
        var camera, cameraControls;
        var geometry, meshObject;
        var material = new THREE.MeshNormalMaterial();

        function initialize() {
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setClearColor(0x0f1012, 1);

            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 0, 40);
            scene.add(camera);

            cameraControls = new THREE.OrbitControls(camera, document.getElementById('container'));
            cameraControls.enableDamping = true;
            cameraControls.dampingFactor = 0.1;
            cameraControls.enablePan = false;
            cameraControls.rotateSpeed = 1.5;
            cameraControls.position0 = new THREE.Vector3(-0.528, 0.437, -0.728);
            cameraControls.position0.multiplyScalar(6);
            cameraControls.reset();
            
            window.addEventListener('resize', function() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }, false);
        }

        function animate() {
            requestAnimationFrame(animate);
            cameraControls.update();
            renderer.render(scene, camera);
        }

        initialize();
        animate();

        document.getElementById('generate').addEventListener('click', generateShape);
        document.getElementById('save').addEventListener('click', function() { currentShape.saveSTLFile(); });
    </script>
  </body>
</html>
