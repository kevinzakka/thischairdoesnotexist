<html>
<head>
    <title>GAN generated chairs</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body>
    <div id="container"></div>

    <style>
        body {
            padding: 0;
            margin: 0;

            color: white;
            background-color: #171717;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/onnxjs/dist/onnx.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/marchingcubes.js"></script>
    <script>
        "use strict";

        // https://filosophy.org/code/normal-distributed-random-values-in-javascript-using-the-ziggurat-algorithm/
        function Ziggurat() {
            var jsr = 123456789;

            var wn = Array(128);
            var fn = Array(128);
            var kn = Array(128);

            function RNOR() {
                var hz = SHR3();
                var iz = hz & 127;
                return (Math.abs(hz) < kn[iz]) ? hz * wn[iz] : nfix(hz, iz);
            }

            this.nextGaussian = function() {
                return RNOR();
            }

            function nfix(hz, iz){
                var r = 3.442619855899;
                var r1 = 1.0 / r;
                var x;
                var y;
                while (true) {
                    x = hz * wn[iz];
                    if (iz == 0){
                        x = (-Math.log(UNI()) * r1); 
                        y = -Math.log(UNI());
                        while (y + y < x * x) {
                            x = (-Math.log(UNI()) * r1); 
                            y = -Math.log(UNI());
                        }
                        return (hz > 0) ? r+x : -r-x;
                    }

                    if (fn[iz] + UNI() * (fn[iz-1] - fn[iz]) < Math.exp(-0.5 * x * x)){
                        return x;
                    }
                    hz = SHR3();
                    iz = hz & 127;

                    if (Math.abs(hz) < kn[iz]){
                        return (hz * wn[iz]);
                    }
                }
            }

            function SHR3() {
                var jz = jsr;
                var jzr = jsr;
                jzr ^= (jzr << 13);
                jzr ^= (jzr >>> 17);
                jzr ^= (jzr << 5);
                jsr = jzr;
                return (jz+jzr) | 0;
            }

            function UNI() {
                return 0.5 * (1 + SHR3() / -Math.pow(2,31));
            }

            function zigset() {
                // seed generator based on current time
                jsr ^= new Date().getTime();

                var m1 = 2147483648.0;
                var dn = 3.442619855899;
                var tn = dn;
                var vn = 9.91256303526217e-3;
                
                var q = vn / Math.exp(-0.5 * dn * dn);
                kn[0] = Math.floor((dn/q)*m1);
                kn[1] = 0;

                wn[0] = q / m1;
                wn[127] = dn / m1;

                fn[0] = 1.0;
                fn[127] = Math.exp(-0.5 * dn * dn);

                for (var i = 126; i >= 1; i--) {
                    dn = Math.sqrt(-2.0 * Math.log( vn / dn + Math.exp( -0.5 * dn * dn)));
                    kn[i+1] = Math.floor((dn/tn)*m1);
                    tn = dn;
                    fn[i] = Math.exp(-0.5 * dn * dn);
                    wn[i] = dn / m1;
                }
            }
            zigset();
        }

        const normalDistribution = new Ziggurat();
        const LATENT_CODE_SIZE = 128;
        var resolution = 16;

        function getGrid(resolution) {
            var values = new Array(Math.pow(resolution, 3) * 3);
            var p = 0;
            for (var x = 0; x < resolution; x++) {
                for (var y = 0; y < resolution; y++) {
                    for (var z = 0; z < resolution; z++) {
                        values[p + 0] = -1 + 2 * x / (resolution - 1);
                        values[p + 1] = -1 + 2 * y / (resolution - 1);
                        values[p + 2] = -1 + 2 * z / (resolution - 1);
                        p += 3;
                    }
                }
            }
            return new onnx.Tensor(values, 'float32', [Math.pow(resolution, 3), 3]);
        }

        function getRandomLatentCode() {
            var values = new Array(LATENT_CODE_SIZE);
            for (var i = 0; i < LATENT_CODE_SIZE; i++) {
                values[i] = normalDistribution.nextGaussian();
            }
            return values;
        }

        function repeatLatentCode(code, repeats) {
            var result = new Array(LATENT_CODE_SIZE * repeats);            
            for (var i = 0; i < repeats; i++) {
                for (var j = 0; j < LATENT_CODE_SIZE; j++) {
                    result[i * LATENT_CODE_SIZE + j] = code[j];
                }
            }
            return new onnx.Tensor(result, 'float32', [repeats, LATENT_CODE_SIZE]);
        }

        function processVolume(voxels, resolution, offset=0.04) {
            var paddedResolution = resolution + 2;
            var result = new Float32Array(Math.pow(paddedResolution, 3));
            result.fill(1);
            for (var x = 0; x < resolution; x++) {
                for (var y = 0; y < resolution; y++) {
                    for (var z = 0; z < resolution; z++) {
                        result[(x + 1) * paddedResolution * paddedResolution + (y + 1) * paddedResolution + z + 1] = voxels[x * resolution * resolution + y * resolution + z] - offset;
                    }
                }
            }
            return result;
        }

        function writeVector(view, offset, vector) {
            view.setFloat32(offset, vector[2], true);
            view.setFloat32(offset + 4, vector[0], true);
            view.setFloat32(offset + 8, vector[1], true);
        }

        function createSTLFile(mesh) {
            var size = 84 + 50 * mesh.triangles.length;
            var buffer = new ArrayBuffer(size);
            let view = new DataView(buffer, 0, size);

            for (var i = 0; i < 80; i++) {
                view.setInt8(i, 0);
            }
            
            var p = 80;
            view.setInt32(p, mesh.triangles.length, true);
            p += 4;

            for (var triangle of mesh.triangles) {
                writeVector(view, p, [1, 0, 0]); // normal
                writeVector(view, p + 12, mesh.vertices[triangle[0]]);
                writeVector(view, p + 24, mesh.vertices[triangle[1]]);
                writeVector(view, p + 36, mesh.vertices[triangle[2]]);
                view.setInt16(p + 48, 0, true);
                p += 50;
            }

            return buffer;
        }

        function saveSTLFile(mesh, filename = "shape.stl") {
            let blob = new Blob([createSTLFile(mesh)], { type: "application/octet-stream" });
            let link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        const onnxSession = new onnx.InferenceSession();
        var grid = getGrid(resolution);

        function generateShape() {
            var latentCode = repeatLatentCode(getRandomLatentCode(), Math.pow(resolution, 3));
            onnxSession.run([grid, latentCode]).then(output => {
                var voxels = output.values().next().value.data;
                voxels = processVolume(voxels, resolution);
                var paddedResolution = resolution + 2;            
                var mesh = marchingCubes([paddedResolution, paddedResolution, paddedResolution], (x, y, z) => voxels[paddedResolution * paddedResolution * x + paddedResolution * y + z]);
                updateMesh(mesh);
            });
        }
        
        onnxSession.loadModel("chairs.onnx").then(() => {
            generateShape();
        });

        var scene, renderer;
        var camera, cameraControls;
        var geometry, meshObject;
        var material = new THREE.MeshNormalMaterial();

        function createGeometryFromMesh(mesh) {                
            geometry = new THREE.Geometry();
            geometry.vertices.length = 0;
            geometry.faces.length = 0;

            for (var i = 0; i < mesh.vertices.length; ++i) {
                var v = mesh.vertices[i];
                geometry.vertices.push(new THREE.Vector3(v[0], v[1], v[2]));
            }

            for (var i = 0; i < mesh.triangles.length; ++i) {
                var f = mesh.triangles[i];
                geometry.faces.push(new THREE.Face3(f[0], f[1], f[2]));
            }

            var cb = new THREE.Vector3(), ab = new THREE.Vector3();
            for (var i = 0; i < geometry.faces.length; ++i) {
                var f = geometry.faces[i];
                var vA = geometry.vertices[f.a];
                var vB = geometry.vertices[f.b];
                var vC = geometry.vertices[f.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb = cb.cross(ab);
                cb.normalize();
                if (mesh.triangles[i].length == 3) {
                    f.normal.copy(cb)
                    continue;
                }
                f.normal.copy(cb);
            }

            geometry.verticesNeedUpdate = true;
            geometry.elementsNeedUpdate = true;
            geometry.normalsNeedUpdate = true;

            geometry.computeBoundingBox();

            return geometry;
        }

        function updateMesh(mesh) {
            scene.remove(meshObject);

            var geometry = createGeometryFromMesh(mesh);
            meshObject = new THREE.Mesh(geometry, material);

            var boundingBox = geometry.boundingBox;
            meshObject.position.x = -(boundingBox.max.x + boundingBox.min.x) / 2.0;
            meshObject.position.y = -(boundingBox.max.y + boundingBox.min.y) / 2.0;
            meshObject.position.z = -(boundingBox.max.z + boundingBox.min.z) / 2.0;

            scene.add(meshObject);
        }

        function initialize() {
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setClearColor(0x171717, 1);

            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 0, 40);
            scene.add(camera);

            cameraControls = new THREE.OrbitControls(camera, document.getElementById('container'));
            cameraControls.enableDamping = true;
            cameraControls.dampingFactor = 0.1;
            cameraControls.enablePan = false;
            cameraControls.rotateSpeed = 1.5;
            cameraControls.position0 = new THREE.Vector3(-29, 24, -40);
            cameraControls.reset();
            
            window.addEventListener('resize', function() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }, false);

            scene.add(new THREE.AmbientLight(Math.random() * 0xffffff));
            var light = new THREE.DirectionalLight(Math.random() * 0xffffff);
            light.position.set(Math.random(), Math.random(), Math.random()).normalize();
            scene.add(light);
        }

        function animate() {
            requestAnimationFrame(animate);
            cameraControls.update();
            renderer.render(scene, camera);
        }

        initialize();
        animate();
    </script>
  </body>
</html>
